#include "entity.hpp"

/*Glare::Entity_handle Glare::Entity_container::at(Glare::Entity_container::size_type index)
{
	// if index < size && element[index].counter is up to date
	// return elem

	// else
	// return nullptr
}*/

/*Glare::Entity_handle Glare::Entity_container::add(Glare::Entity)
{
	if(free_slots.size() != 0) { // free slots available
		// get index from free_slots and pop_back
	} else {
		// create new elem in slot_redirect with push_back
	}

	// push_back new elem with index and counter
	// set counter of index elem and set index to elem position
	// ++counter


}*/

/*void Glare::Entity_container::remove(Glare::Entity_handle)
{
	// check handle's version to make sure it's up to date

	// update the index[] element of the previous last element to point to its new position
	// update the index[] element of the deleted element to show it is deleted??

	// push_back index[] of deleted element to free list

	// get the index of the last element in elems
	// swap the last element with the element to be deleted
	// pop_back
}*/
